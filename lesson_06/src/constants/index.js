import {Task} from '@/models'

import Task01 from '@/features/Task01'
import Task02 from '@/features/Task02'
import Task03 from '@/features/Task03'
import Task04 from '@/features/Task04'

export const APP_TITLE = 'React ДЗ №6'

export const TASKS = [
  new Task({
    title: 'Оптимізація вибіркового рендеру з useMemo та React.memo',
    shortTitle: 'Задача №1',
    description:
      'Створіть компонент-калькулятор, який має два незалежні поля вводу: одне для числа A і одне для числа B. Також є окремий компонент ResultDisplay, який відображає A + B. Обгорніть ResultDisplay у React.memo(). Використайте useMemo в батьківському компоненті, щоб обчислити A + B і передати цей результат до ResultDisplay. Переконайтеся, що ResultDisplay ререндериться лише тоді, коли змінюються A або B, а не коли змінюється інший незалежний стан у батьківському компоненті (наприклад, лічильник, що не впливає на A чи B).',
    component: Task01,
  }),
  new Task({
    title: 'Таблиця з фільтрацією та сортуванням, чутлива до UI',
    shortTitle: 'Задача №2',
    description: `Створіть компонент DataGrid (батьківський) та GridRow (дочірній).
      DataGrid отримує великий масив даних, має поле вводу для фільтрації, кнопки для сортування за різними колонками.
      GridRow (обгорнутий у React.memo) відображає один рядок даних.
      Використайте useDeferredValue для пошукового запиту та/або параметрів сортування.
      Використайте useMemo для обчислення відфільтрованих та відсортованих даних на основі відкладених значень.
      Використайте useCallback для функцій-обробників сортування та інших інтерактивних елементів, які передаються до дочірніх компонентів.
      Мета: забезпечити швидкий відгук на введення та кліки, навіть якщо обробка даних займає час.`,
    component: Task02,
  }),
  new Task({
    title: 'useWindowSize – розмір вікна браузера',
    shortTitle: 'Задача №3',
    description: `Створіть кастомний хук useWindowSize, який повертає поточну ширину та висоту вікна браузера. Він повинен оновлюватися при зміні розміру вікна.
    Створіть компонент, який відображає поточні розміри вікна браузера (ширина x висота), використовуючи useWindowSize. На основі розмірів відображати іконки монітора, планшета або телефона.`,
    component: Task03,
  }),
  new Task({
    title: 'useDebounce – відкладений виклик функції',
    shortTitle: 'Задача №4',
    description: `
    Створіть кастомний хук useDebounce, який приймає значення та затримку в мілісекундах. Він повинен повертати "відкладене" значення, яке оновлюється лише після того, як минув заданий час без змін.
    Створіть поле пошуку, де результати пошуку оновлюються не відразу після кожного символу, а з невеликою затримкою (наприклад, 500мс) після зупинки введення, використовуючи useDebounce.`,
    component: Task04,
  }),
]
